# Спецкурс по языку Java

#### Гордеева Ольга Александровна

4 курс 1 полугодие (7 семестр)

# Лабораторные работы

> Если в папке лабораторной работы нет файлов программы или появляются ошибки при запуске, вы всегда можете найти код в конце отчёта.

## Лабораторная работа 1

Основы языка Ява. Пакеты. Области видимости.

**Цель задания:** изучить структуру исходного кода программ на Java, особенности областей видимости, структуру пакетов, особенности использования командной строки для компиляции и запуска программ на Java.

Для выполнения задания использовать простейший текстовый редактор (блокнот). Для компиляции и запуска приложений использовать командную строку. Рекомендуется каждое задание выполнять в отдельном каталоге.

**Задание 1**

Запустите компилятор javac и изучите форматы задания параметров компилятора. Запустите программу java и изучите с форматы задания параметров запуска виртуальной машины Java (JVM).

**Задание 2**

Cоздайте файл FirstProgram.java, содержащий исходный код одного пустого класса с именем FirstClass:

```java
--- FirstProgram.java ----------------------------------------
class FirstClass {
}
------------------------------------------------------------------
```

Для запуска исполняемого файла выполните следующие действия:
- откомпилируйте файл с помощью компилятора javac. Для этого необходимо выполнить команду “javac <Полное имя файла с расширением>”;
- запустите полученный файл класса на выполнение с помощью команды `“java <Имя класса>”`. 

Примечание: запуск файла класса лучше выполнить командой `“java –classpath <Путь к файлу> <Имя файла класса без расширения>”`

Обратите внимание на то, что на вход компилятора необходимо подавать имя файла с расширением, на вход JVM – без расширения. Имена файлов не должны содержать пробелов и русских символов.

Добавьте в класс метод main():

```java
--- FirstProgram.java ----------------------------------------
class FirstClass {
	void main(String[] s) {
		System.out.println(“Hello world!!!”);
	}
}
------------------------------------------------------------------
```

Откомпилируйте и запустите программу на выполнение.

Логично предположить, что метод main() должен быть статическим, т.к. на момент запуска программы ни одного объекта типа MyFirstClass не существует. Сделайте метод статическим, снова откомпилируйте и запустите программу.

Внесите в текст программы необходимые для ее запуска изменения, откомпилируйте и запустите программу.

**Задание 3**

Замените текст метода main() на следующий:

```java
--- FirstClass.main -------------------------------------------
for (int i = 0; i < s.length; i++)
	System.out.println(s[i]);
------------------------------------------------------------------
```

Откомпилируйте и запустите программу, добавив в командную строку ряд аргументов. Аргументы командной строки записываются после имени запускаемого файла через пробелы. Например,  `“java –classpath <Путь к файлу> FirstClass arg1 arg2 arg3 arg4 arg5”.`

**Задание 4**

В том же файле FirstProgram.java после описания класса FirstClass добавьте описание второго класса SecondClass, реализующего следующую функциональность:
- имеет два приватных поля типа int;
- методы для получения и модификации их значений;
- конструктор, создающий объект и инициализирующий значения полей;
- метод с возвращаемым типом int, реализующий над этими числами какое-либо действие (сложение, умножение и т.п.).

Код метода FirstClass.main() при этом следует заменить на следующий (в угловых скобках указаны элементы, имена которых следует подставить при написании программы):

```java
--- FirstClass.main --------------------------------------------
<Создание и инициализация объекта “o” типа SecondClass>;
int i, j;
for (i = 1; i <= 8; i++) {
	for(j = 1; j <= 8; j++) {
		o.<Метод установки значения первого числового поля>(i);
		o.<Метод установки значения второго числового поля>(j);
		System.out.print(o.<Метод, реализующий действие над числами>());
		System.out.print(" ");
	}
	System.out.println();
}
------------------------------------------------------------------
```

Откомпилируйте и запустите программу.

**Задание 5**

Вынесите код класса SecondClass без изменений в отдельный файл с именем FirstPackage.java, и поместите его в поддиректорию FirstPackage.

Откомпилируйте исходный код. 

Попробуйте откомпилировать файл FirstProgram.java.

Добавьте в начало исходного кода в файле FirstProgram.java следующий код:

```java
--- FirstProgram.java ------------------------------------------
import FirstPackage.*;
------------------------------------------------------------------
```

Снова попробуйте откомпилировать FirstProgram.java. Далее, следуя сообщениям компилятора и изменяя исходный код программы, добейтесь ее работоспособности.

**Задание 6**

Запустите программу jar, предназначенную для создания архивов, и  изучите форматы задания ключей для формирования архивов.

Скопируйте в рабочую папку, сохранив структуру каталогов, только файлы с расширением class, полученные в результате выполнения задания 5.

Создайте файл manifest.mf, содержащий следующий код:

```java
--- manifest.mf -------------------------------------------------
Manifest-Version: 1.0
Created-By: <Ваши фамилии>
Main-Class: FirstClass
------------------------------------------------------------------
```

Создайте архив myfirst.jar, включив в него полученные ранее файлы классов и указав созданный вами манифест-файл. Переместите полученный файл в другую директорию и запустите его на выполнение.

**Примечание 1:** Команда создания jar-архива выглядит следующим образом: “jar –cvfm <Полное имя jar-архива с расширением> <Полное имя манифест-файла с расширением> -C <Путь к папке с файлами class>\ .”; выделенный фрагмент является частью синтаксиса, его не терять.
команда запуска jar-архива выглядит следующим образом: “java –jar <Полное имя jar-архива с расширением>” .

**Примечание 2:** В примечании 1 символы < и > означают начало и конец пользовательской информации, их не нужно писать в команде. 

## Лабораторная работа 2

Синтаксис языка.

**Цель задания:** В процессе написания тестовых заданий ознакомиться с основными конструкциями языка Java, правилами именования, структурированными типами и принципами создания классов.

**Задание**

Создать класс, реализующий работу с векторами (набор вещественных чисел, координат) и базовые операции векторной арифметики. Класс должен удовлетворять следующим требованиям.

Экземпляр должен соответствовать вектору фиксированной длины (она задается как параметр конструктора). Конструктор без параметра не создавать.

Должны быть реализованы следующие методы:
- доступа к элементам вектора (получения значения и изменения значения),
- получения «длины» вектора (количества его элементов),
- поиска минимального и максимального значений из элементов вектора,
- сортировки вектора (по возрастанию или убыванию – на ваш выбор),
- нахождения евклидовой нормы,
- умножения вектора на число,
- сложения двух векторов (статический),
- нахождения скалярного произведения двух векторов (статический).

**Примечание 1.** В процессе выполнения задания НЕЛЬЗЯ пользоваться утилитными классами Java (кроме метода Math.sqrt()).

**Примечание 2.** Выполнять задание нужно в среде разработки.

## Лабораторная работа 3

В процессе написания тестовых заданий ознакомиться с концепцией интерфейсов и исключительными ситуациями в Java.

**Задание 1**

Описать два класса с идентичным внешним контрактом, принадлежащих одной предметной области (функциональная семантика предметной области выбирается самостоятельно). 

Оба класса должны содержать:
- поле – массив, поле строкового типа, поле целого типа, возможно добавление других необходимых полей;
- конструктор по умолчанию, и конструктор с параметрами, позволяющими полностью инициализировать объект;
- методы доступа к элементам массива и к полям;
- бизнес-метод, реализующий некоторую функцию от элементов массива и полей объектов классов (арифметическую, логическую, конкатенацию и т.п.).

**Задание 2**

Описать интерфейс, задающий список сигнатур методов доступа к полям объектов и функционального метода, оба класса должны реализовывать интерфейс.

**Задание 3**

В классах корректно переопределить методы класса Object – toString(), equals(), hashCode().

**Задание 4**

Разработать программное приложение, имеющее адекватный интерфейс пользователя, в котором организовать базу (массив) объектов типа интерфейс и заполнить ее объектами описанных типов вперемежку (по желанию пользователя приложения). 

Выполнить следующие действия:
- вывести полную информацию обо всех объектах массива;
- найти в массиве объекты, бизнес-метод которых возвращают одинаковый результат, поместить такие объекты в другие массивы (в новых массивах хранятся объекты из исходной балы, имеющие одинаковый результат выполнения бизнес-метода); 
- разбить исходный массив на два массива, в которых будут храниться однотипные элементы (проверять реальный тип объекта);

**Задание 5**

При описании классов описать собственные исключения - одно объявляемое (наследное от Exception) и одно необъявляемое (наследное от RuntimeException) исключения, характеризующие ошибки, связанные с выполнением методов классов и учитывающие специфику исключения (объявляемость и необъявляемость). Обычно объявляемое исключение связано с логикой работы метода, поэтому его, видимо, надо выбрасывать из бизнес-метода. Необъявляемое исключение можно связать с некорректными входными данными для методов-сеттеров. В соответствующих методах выбрасывать/при выбросе контролировать описанные исключения.

**Пример семантики.** Класс «Серия сочинений» (поле – массив хранит количество страниц в каждой книге серии, второе поле – название серии, третье поле – количество страниц в книге, занятых вводной информацией, бизнес-метод – подсчет общего количества страниц серии без учета вводных страниц книг) и класс «Сборник статей» (поле – массив хранит количество страниц каждой статьи, второе поле – название сборника, третье поле – максимально допустимое количество страниц для аннотации статьи, бизнес-метод – подсчет общего количества страниц без учета аннотаций статей). Необъявляемые исключение – невалидные значения в параметрах конструкторов и методов доступа (неположительная длина массива, несуществующий индекс в массиве, недопустимое значение поля, etc.), объявляемое исключение – ошибка бизнес-метода.

## Лабораторная работа 4

В процессе написания тестовых заданий ознакомиться с потоковым механизмом ввода/вывода в Java.

**Задание 1**

Модифицировать классы из лабораторной работы №3 следующим образом:
- в интерфейс добавить следующие методы:
	- записи в байтовый поток `void output(OutputStream out)`;
	- записи в символьный поток `void write(Writer out)`;
- реализовать добавленные в интерфейс методы в обоих классах вашей иерархии;
- описать новый класс со следующими статическими методами:
	- записи в байтовый поток `void output<Интерфейс>(<Интерфейс> o, OutputStream out)`;
	- чтения из байтового потока `<Интерфейс> input<Интерфейс>(InputStream in)`;
	- записи в символьный поток `void write<Интерфейс> (<Интерфейс> o, Writer out)`;
	- чтения из символьного потока `<Интерфейс> read<Интерфейс>(Reader in)`;

В статических методах записи делегировать вызов соответствующему методу интерфейса.

В обоих случаях записанный объект должен представлять собой последовательность значений своих полей.

В случае символьного потока рекомендуется считать, что один объект записывается в одну строку (поля разделены пробелами). Для чтения элемента из символьного потока можно использовать класс `StreamTokenizer`. 

**Задание 2**

Модифицировать классы в иерархии таким образом, чтобы они были сериализуемы. Добавить в класс со статическими методами методы для вывода/ввода сериализованных объектов.
- вывод сериализованных объектов `void serialize<Интерфейс> (<Интерфейс> o, OutputStream out)`;
- ввод десериализованного объекта `<Интерфейс> deserialize<Интерфейс>(InputStream in)`;

**Задание 3**

Добавить в класс со статическими методами методы для форматного текстового ввода и вывода.
- вывод с объектов `void writeFormat<Интерфейс> (<Интерфейс> o, Writer out)`;
- ввод объекта (параметром метода является объект типа Scanner) `<Интерфейс> readFormat<Интерфейс>(Scanner in)`;

**Задание 4**

Организовать примитивный интерфейс пользователя, выполняющий следующие функции
- заполнение базы элементов с консоли, с выбором типа элемента пользователем;
- цикл записи в байтовый поток и цикл чтения из байтового потока базы элементов с помощью разработанных в задании 1 методов байтового ввода/вывода;
- цикл записи в текстовый поток и цикл чтения из текстового потока базы элементов с помощью разработанных в задании 1 методов текстового ввода/вывода;
- цикл записи в байтовый поток и цикл чтения из байтового потока базы элементов с помощью разработанных в задании 2 методов сериализации/десериализации.
- цикл записи в текстовый поток и цикл чтения из текстового потока базы элементов с помощью разработанных в задании 3 методов текстового форматного ввода/вывода (возможны особенности преобразования вещественных чисел, необходимо задать нужную настройку локали);

Протестировать разработанные методы работы с потоками, а также возможности сериализации. В качестве источника и получателя данных использовать файлы.

## Лабораторная работа 5

В процессе написания тестовых заданий ознакомиться с общими принципами создания многопоточных приложений.

**Задание 1**

Создать два класса нитей, наследующих от класса Thread, взаимодействующих друг с другом с помощью одного промежуточного объекта типа интерфейс из вашей иерархии (см л.р. №3).

Первая нить последовательно заполняет поле-массив промежуточного объекта (изначально он заполнен значениями по умолчанию) произвольными различными величинами (например, случайными), отличными от нуля. Каждый раз, когда она помещает значение в массив, она выводит на экран сообщение вида `Write: ### to position ###`. По достижении конца массива нить заканчивает свое выполнение.

Вторая нить последовательно считывает значения из массива и выводит их на экран сообщениями вида `Read: ### from position ###`. По достижении конца массива нить заканчивает свое выполнение.

В методе main() следует создать 3 участвующих в процессе объекта (две нити и объект интерфейса для записи/чтения в него) и запустить нити на выполнение. Запустите программу несколько раз. Попробуйте варьировать приоритеты нитей.

**Задание 2**

Создайте два новых класса нитей (реализуют интерфейс `Runnable`), обеспечивающих последовательность операций чтения-записи (т.е. на экран сообщения выводятся в порядке write-read-write-read-…) независимо от приоритетов потоков. Для этого потребуется описать некий вспомогательный класс `<Интерфейс>Synchronizer`, объект которого и будет использоваться при взаимодействии нитей. Сообщения на экране, выводимые объектом-посредником, должны соответствовать формату в задании 1. Протестируйте работу описанных классов так же, как и в задании 1. 

Пример класса объекта-посредника (данный пример предлагает один из вариантов, причем не самый лучший, он легко может быть изменен и оптимизирован):

```java
public class <Интерфейс>Synchronizer {
    private <Интерфейс>  i;
    private volatile int current = 0;
    private Object lock = new Object();
    private boolean set = false;
   
    public <Интерфейс>Synchronizer(<Интерфейс> i) {
        this.i = i;
    }
   
    public double read() throws InterruptedException {
        double val;
        synchronized(lock) {
            if (!canRead()) throw new InterruptedException();
            while (!set)
                lock.wait();
            val = i.getElement(current++);
            System.out.println("Read: " + val);
            set = false;
            lock.notifyAll();
        }
        return val;
    }  
   
    public void write(double val) throws InterruptedException {
        synchronized(lock) {
            if (!canWrite()) throw new InterruptedException();
            while (set)
                lock.wait();
            i.setElement(current, val);
            System.out.println("Write: " + val);
            set = true;
            lock.notifyAll();
        }
    }
    
    public boolean canRead() {
        return current < i.getSize();
    }
    
    public boolean canWrite() {
        return (!set && current < i.getSize()) || (set && current < i.getSize() - 1);
    }
}
```

**Задание 3**

Добавить в класс со статическими методами обработки объектов (созданный в л. р. 4) реализацию метода `<Интерфейс> synchronized<Интерфейс>(<Интерфейс> i`), возвращающего ссылку на оболочку указанного интерфейса, безопасную с точки зрения многопоточности. Для этого потребуется описать новый класс, реализующий ваш интерфейс `<Интерфейс>` и представляющий собой оболочку, синхронизирующую все методы интерфейса (состоящую из синхронизированных методов вашего интерфейса). Протестировать его работу.

## Лабораторная работа 6

В процессе написания тестовых заданий ознакомиться с механизмом образцов проектирования «Итератор», «Декоратор» и упрощенной версией «Фабричного метода».

**Задание 1**

Модифицировать ваш интерфейс таким образом, чтобы он реализовывал интерфейс `java.util.Iterable<>`.

Реализовать метод `java.util.Iterator<> iterator()`, унаследованный из интерфейса, в двух ваших классах. Для этого, естественно, следует описать некий дополнительный класс итератора с соответствующими методами итератора (из стандартного интерфейса `java.util.Iterator<>`). Объект итератора и возвращается из метода `iterator()` ваших классов. Итератор должен позволять обойти все элементы поля-массива.

Проверить работу итераторов с использованием цикла while и улучшенного цикла for.

**Задание 2**

Добавить в класс со статическими методами описание еще одного статического метода `<Интерфейс> unmodifiable<Интерфейс>(<Интерфейс> о)`, возвращающего ссылку на экземпляр неизменяемой оболочки указанного объекта. Для этого нужно написать новый класс-декоратор для типа <Интерфейс>, который содержит объект типа `<Интерфейс>`, сам реализует `<Интерфейс>`, а все методы интерфейса делегирует внутреннему объекту, кроме методов изменения объекта. Декоратор выбрасывает исключение `UnsupportedOperationException` в случае попытки изменения состояния внутреннего объекта.

**Задание 3**

Описать новый интерфейс `<Интерфейс>Factory`, содержащий метод `createInstance()` для создания экземпляра по умолчанию (опционально в фабрику можно добавить  методы с параметрами для создания объектов).

**Задание 4**

В классе со статическими методами создать приватное статическое поле `factory` типа `<Интерфейс>Factory` и соответствующий ему публичный метод `set<Интерфейс>Factory()`, позволяющие, соответственно, хранить ссылку и устанавливать ссылку на текущую фабрику объектов (ПРИМЕЧАНИЕ. Метода `get<Интерфейс>Factory()` не создавать!). Для каждого из двух классов вашей иерархии нужно описать класс соответствующей фабрики (реализующей метод `createInstance()`). По умолчанию поле должно ссылаться на объект некоторого (одного из двух) класса `Factory`, порождающего экземпляры одного из ваших классов.

**Задание 5**

В классе со статическими методами описать метод `public static  createInstance()`, с помощью текущей фабрики создающий новый экземпляр объекта. В остальных методах этого класса заменить прямое создание экземпляров на вызов этого метода. При тестировании (в методе `main()`) также создавать объекты только через вызов этого метода.

## Лабораторная работа 7

В процессе написания задания с технологией Swing, обработкой событий и PLaF. Можно использовать JavaFX. Тогда смена стиля отображения реализуется через CSS.

**Задание 1**

Написать оконное Swing-приложение, реализующее вывод на экран массива объектов вашего интерфейса. Сам массив (база из лабораторной работы 3) заполняется автоматически либо загружается из файла. Форматы файлов соответствуют форматам работы с потоками данных в лабораторной работе 4.

Реализовать следующую функциональность:
- в меню должны быть следующие пункты:
	+ загрузка базы из файла;
	+ автоматическое заполнение базы;
- отображение базы производится в панели с горизонтальным и вертикальным скроллингом;
- при отображении базы в рамках большой панели динамически сверху вниз добавляются панели с описанием соответствующего объекта из базы (описание самого объекта в пределах своей панели конфигурируется в соответствии с вашим выбором). Вложенных панелей должно быть столько, сколько объектов содержится в базе;
- при нажатии мышкой на панель объекта должно появляться его описание в дополнительном диалоговом окне. При этом нужно указать номер объекта в базе.

**Задание 2**

Добавить на форму радиокнопку на несколько позиций, соответствующих различным доступным PLaF. Можно добавить такой пункт в меню. При выборе пользователем одного из предлагаемых значений должен изменяться внешний вид программы.

Примечание. Вместо Swing можно реализовать приложение FX, однако тогда стили придется менять несколько иначе.
